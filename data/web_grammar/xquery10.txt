XQuery 1.0: An XML Query Language
W3C Recommendation 23 January 2007
http://www.w3.org/TR/xquery/

A XQuery Grammar

A.1 EBNF

[1]    	Module 	   ::=    	VersionDecl? (LibraryModule  | MainModule)
[2]    	VersionDecl 	   ::=    	"xquery" "version" StringLiteral ("encoding" StringLiteral)? Separator
[3]    	MainModule 	   ::=    	Prolog QueryBody
[4]    	LibraryModule 	   ::=    	ModuleDecl Prolog
[5]    	ModuleDecl 	   ::=    	"module" "namespace" NCName "=" URILiteral Separator
[6]    	Prolog 	   ::=    	((DefaultNamespaceDecl | Setter | NamespaceDecl | Import) Separator)* ((VarDecl | FunctionDecl | OptionDecl) Separator)*
[7]    	Setter 	   ::=    	BoundarySpaceDecl | DefaultCollationDecl | BaseURIDecl | ConstructionDecl | OrderingModeDecl | EmptyOrderDecl | CopyNamespacesDecl
[8]    	Import 	   ::=    	SchemaImport | ModuleImport
[9]    	Separator 	   ::=    	";"
[10]    	NamespaceDecl 	   ::=    	"declare" "namespace" NCName "=" URILiteral
[11]    	BoundarySpaceDecl 	   ::=    	"declare" "boundary-space" ("preserve" | "strip")
[12]    	DefaultNamespaceDecl 	   ::=    	"declare" "default" ("element" | "function") "namespace" URILiteral
[13]    	OptionDecl 	   ::=    	"declare" "option" QName StringLiteral
[14]    	OrderingModeDecl 	   ::=    	"declare" "ordering" ("ordered" | "unordered")
[15]    	EmptyOrderDecl 	   ::=    	"declare" "default" "order" "empty" ("greatest" | "least")
[16]    	CopyNamespacesDecl 	   ::=    	"declare" "copy-namespaces" PreserveMode "," InheritMode
[17]    	PreserveMode 	   ::=    	"preserve" | "no-preserve"
[18]    	InheritMode 	   ::=    	"inherit" | "no-inherit"
[19]    	DefaultCollationDecl 	   ::=    	"declare" "default" "collation" URILiteral
[20]    	BaseURIDecl 	   ::=    	"declare" "base-uri" URILiteral
[21]    	SchemaImport 	   ::=    	"import" "schema" SchemaPrefix? URILiteral ("at" URILiteral ("," URILiteral)*)?
[22]    	SchemaPrefix 	   ::=    	("namespace" NCName "=") | ("default" "element" "namespace")
[23]    	ModuleImport 	   ::=    	"import" "module" ("namespace" NCName "=")? URILiteral ("at" URILiteral ("," URILiteral)*)?
[24]    	VarDecl 	   ::=    	"declare" "variable" "$" QName TypeDeclaration? ((":=" ExprSingle) | "external")
[25]    	ConstructionDecl 	   ::=    	"declare" "construction" ("strip" | "preserve")
[26]    	FunctionDecl 	   ::=    	"declare" "function" QName "(" ParamList? ")" ("as" SequenceType)? (EnclosedExpr | "external")
[27]    	ParamList 	   ::=    	Param ("," Param)*
[28]    	Param 	   ::=    	"$" QName TypeDeclaration?
[29]    	EnclosedExpr 	   ::=    	"{" Expr "}"
[30]    	QueryBody 	   ::=    	Expr
[31]    	Expr 	   ::=    	ExprSingle ("," ExprSingle)*
[32]    	ExprSingle 	   ::=    	FLWORExpr
			| QuantifiedExpr
			| TypeswitchExpr
			| IfExpr
			| OrExpr
[33]    	FLWORExpr 	   ::=    	(ForClause | LetClause)+ WhereClause? OrderByClause? "return" ExprSingle
[34]    	ForClause 	   ::=    	"for" "$" VarName TypeDeclaration? PositionalVar? "in" ExprSingle ("," "$" VarName TypeDeclaration? PositionalVar? "in" ExprSingle)*
[35]    	PositionalVar 	   ::=    	"at" "$" VarName
[36]    	LetClause 	   ::=    	"let" "$" VarName TypeDeclaration? ":=" ExprSingle ("," "$" VarName TypeDeclaration? ":=" ExprSingle)*
[37]    	WhereClause 	   ::=    	"where" ExprSingle
[38]    	OrderByClause 	   ::=    	(("order" "by") | ("stable" "order" "by")) OrderSpecList
[39]    	OrderSpecList 	   ::=    	OrderSpec ("," OrderSpec)*
[40]    	OrderSpec 	   ::=    	ExprSingle OrderModifier
[41]    	OrderModifier 	   ::=    	("ascending" | "descending")? ("empty" ("greatest" | "least"))? ("collation" URILiteral)?
[42]    	QuantifiedExpr 	   ::=    	("some" | "every") "$" VarName TypeDeclaration? "in" ExprSingle ("," "$" VarName TypeDeclaration? "in" ExprSingle)* "satisfies" ExprSingle
[43]    	TypeswitchExpr 	   ::=    	"typeswitch" "(" Expr ")" CaseClause+ "default" ("$" VarName)? "return" ExprSingle
[44]    	CaseClause 	   ::=    	"case" ("$" VarName "as")? SequenceType "return" ExprSingle
[45]    	IfExpr 	   ::=    	"if" "(" Expr ")" "then" ExprSingle "else" ExprSingle
[46]    	OrExpr 	   ::=    	AndExpr ( "or" AndExpr )*
[47]    	AndExpr 	   ::=    	ComparisonExpr ( "and" ComparisonExpr )*
[48]    	ComparisonExpr 	   ::=    	RangeExpr ( (ValueComp
			| GeneralComp
			| NodeComp) RangeExpr )?
[49]    	RangeExpr 	   ::=    	AdditiveExpr ( "to" AdditiveExpr )?
[50]    	AdditiveExpr 	   ::=    	MultiplicativeExpr ( ("+" | "-") MultiplicativeExpr )*
[51]    	MultiplicativeExpr 	   ::=    	UnionExpr ( ("*" | "div" | "idiv" | "mod") UnionExpr )*
[52]    	UnionExpr 	   ::=    	IntersectExceptExpr ( ("union" | "|") IntersectExceptExpr )*
[53]    	IntersectExceptExpr 	   ::=    	InstanceofExpr ( ("intersect" | "except") InstanceofExpr )*
[54]    	InstanceofExpr 	   ::=    	TreatExpr ( "instance" "of" SequenceType )?
[55]    	TreatExpr 	   ::=    	CastableExpr ( "treat" "as" SequenceType )?
[56]    	CastableExpr 	   ::=    	CastExpr ( "castable" "as" SingleType )?
[57]    	CastExpr 	   ::=    	UnaryExpr ( "cast" "as" SingleType )?
[58]    	UnaryExpr 	   ::=    	("-" | "+")* ValueExpr
[59]    	ValueExpr 	   ::=    	ValidateExpr | PathExpr | ExtensionExpr
[60]    	GeneralComp 	   ::=    	"=" | "!=" | "<" | "<=" | ">" | ">="
[61]    	ValueComp 	   ::=    	"eq" | "ne" | "lt" | "le" | "gt" | "ge"
[62]    	NodeComp 	   ::=    	"is" | "<<" | ">>"
[63]    	ValidateExpr 	   ::=    	"validate" ValidationMode? "{" Expr "}"
[64]    	ValidationMode 	   ::=    	"lax" | "strict"
[65]    	ExtensionExpr 	   ::=    	Pragma+ "{" Expr? "}"
[66]    	Pragma 	   ::=    	"(#" S? QName (S PragmaContents)? "#)" 	/* ws: explicit */
[67]    	PragmaContents 	   ::=    	(Char* - (Char* '#)' Char*))
[68]    	PathExpr 	   ::=    	("/" RelativePathExpr?)
			| ("//" RelativePathExpr)
			| RelativePathExpr 	/* xgs: leading-lone-slash */
[69]    	RelativePathExpr 	   ::=    	StepExpr (("/" | "//") StepExpr)*
[70]    	StepExpr 	   ::=    	FilterExpr | AxisStep
[71]    	AxisStep 	   ::=    	(ReverseStep | ForwardStep) PredicateList
[72]    	ForwardStep 	   ::=    	(ForwardAxis NodeTest) | AbbrevForwardStep
[73]    	ForwardAxis 	   ::=    	("child" "::")
			| ("descendant" "::")
			| ("attribute" "::")
			| ("self" "::")
			| ("descendant-or-self" "::")
			| ("following-sibling" "::")
			| ("following" "::")
[74]    	AbbrevForwardStep 	   ::=    	"@"? NodeTest
[75]    	ReverseStep 	   ::=    	(ReverseAxis NodeTest) | AbbrevReverseStep
[76]    	ReverseAxis 	   ::=    	("parent" "::")
			| ("ancestor" "::")
			| ("preceding-sibling" "::")
			| ("preceding" "::")
			| ("ancestor-or-self" "::")
[77]    	AbbrevReverseStep 	   ::=    	".."
[78]    	NodeTest 	   ::=    	KindTest | NameTest
[79]    	NameTest 	   ::=    	QName | Wildcard
[80]    	Wildcard 	   ::=    	"*"
			| (NCName ":" "*")
			| ("*" ":" NCName) 	/* ws: explicit */
[81]    	FilterExpr 	   ::=    	PrimaryExpr PredicateList
[82]    	PredicateList 	   ::=    	Predicate*
[83]    	Predicate 	   ::=    	"[" Expr "]"
[84]    	PrimaryExpr 	   ::=    	Literal | VarRef | ParenthesizedExpr | ContextItemExpr | FunctionCall | OrderedExpr | UnorderedExpr | Constructor
[85]    	Literal 	   ::=    	NumericLiteral | StringLiteral
[86]    	NumericLiteral 	   ::=    	IntegerLiteral | DecimalLiteral | DoubleLiteral
[87]    	VarRef 	   ::=    	"$" VarName
[88]    	VarName 	   ::=    	QName
[89]    	ParenthesizedExpr 	   ::=    	"(" Expr? ")"
[90]    	ContextItemExpr 	   ::=    	"."
[91]    	OrderedExpr 	   ::=    	"ordered" "{" Expr "}"
[92]    	UnorderedExpr 	   ::=    	"unordered" "{" Expr "}"
[93]    	FunctionCall 	   ::=    	QName "(" (ExprSingle ("," ExprSingle)*)? ")" 	/* xgs: reserved-function-names */
				/* gn: parens */
[94]    	Constructor 	   ::=    	DirectConstructor
			| ComputedConstructor
[95]    	DirectConstructor 	   ::=    	DirElemConstructor
			| DirCommentConstructor
			| DirPIConstructor
[96]    	DirElemConstructor 	   ::=    	"<" QName DirAttributeList ("/>" | (">" DirElemContent* "</" QName S? ">")) 	/* ws: explicit */
[97]    	DirAttributeList 	   ::=    	(S (QName S? "=" S? DirAttributeValue)?)* 	/* ws: explicit */
[98]    	DirAttributeValue 	   ::=    	('"' (EscapeQuot | QuotAttrValueContent)* '"')
			| ("'" (EscapeApos | AposAttrValueContent)* "'") 	/* ws: explicit */
[99]    	QuotAttrValueContent 	   ::=    	QuotAttrContentChar
			| CommonContent
[100]    	AposAttrValueContent 	   ::=    	AposAttrContentChar
			| CommonContent
[101]    	DirElemContent 	   ::=    	DirectConstructor
			| CDataSection
			| CommonContent
			| ElementContentChar
[102]    	CommonContent 	   ::=    	PredefinedEntityRef | CharRef | "{{" | "}}" | EnclosedExpr
[103]    	DirCommentConstructor 	   ::=    	"<!--" DirCommentContents "-->" 	/* ws: explicit */
[104]    	DirCommentContents 	   ::=    	((Char - '-') | ('-' (Char - '-')))* 	/* ws: explicit */
[105]    	DirPIConstructor 	   ::=    	"<?" PITarget (S DirPIContents)? "?>" 	/* ws: explicit */
[106]    	DirPIContents 	   ::=    	(Char* - (Char* '?>' Char*)) 	/* ws: explicit */
[107]    	CDataSection 	   ::=    	"<![CDATA[" CDataSectionContents "]]>" 	/* ws: explicit */
[108]    	CDataSectionContents 	   ::=    	(Char* - (Char* ']]>' Char*)) 	/* ws: explicit */
[109]    	ComputedConstructor 	   ::=    	CompDocConstructor
			| CompElemConstructor
			| CompAttrConstructor
			| CompTextConstructor
			| CompCommentConstructor
			| CompPIConstructor
[110]    	CompDocConstructor 	   ::=    	"document" "{" Expr "}"
[111]    	CompElemConstructor 	   ::=    	"element" (QName | ("{" Expr "}")) "{" ContentExpr? "}"
[112]    	ContentExpr 	   ::=    	Expr
[113]    	CompAttrConstructor 	   ::=    	"attribute" (QName | ("{" Expr "}")) "{" Expr? "}"
[114]    	CompTextConstructor 	   ::=    	"text" "{" Expr "}"
[115]    	CompCommentConstructor 	   ::=    	"comment" "{" Expr "}"
[116]    	CompPIConstructor 	   ::=    	"processing-instruction" (NCName | ("{" Expr "}")) "{" Expr? "}"
[117]    	SingleType 	   ::=    	AtomicType "?"?
[118]    	TypeDeclaration 	   ::=    	"as" SequenceType
[119]    	SequenceType 	   ::=    	("empty-sequence" "(" ")")
			| (ItemType OccurrenceIndicator?)
[120]    	OccurrenceIndicator 	   ::=    	"?" | "*" | "+" 	/* xgs: occurrence-indicators */
[121]    	ItemType 	   ::=    	KindTest | ("item" "(" ")") | AtomicType
[122]    	AtomicType 	   ::=    	QName
[123]    	KindTest 	   ::=    	DocumentTest
			| ElementTest
			| AttributeTest
			| SchemaElementTest
			| SchemaAttributeTest
			| PITest
			| CommentTest
			| TextTest
			| AnyKindTest
[124]    	AnyKindTest 	   ::=    	"node" "(" ")"
[125]    	DocumentTest 	   ::=    	"document-node" "(" (ElementTest | SchemaElementTest)? ")"
[126]    	TextTest 	   ::=    	"text" "(" ")"
[127]    	CommentTest 	   ::=    	"comment" "(" ")"
[128]    	PITest 	   ::=    	"processing-instruction" "(" (NCName | StringLiteral)? ")"
[129]    	AttributeTest 	   ::=    	"attribute" "(" (AttribNameOrWildcard ("," TypeName)?)? ")"
[130]    	AttribNameOrWildcard 	   ::=    	AttributeName | "*"
[131]    	SchemaAttributeTest 	   ::=    	"schema-attribute" "(" AttributeDeclaration ")"
[132]    	AttributeDeclaration 	   ::=    	AttributeName
[133]    	ElementTest 	   ::=    	"element" "(" (ElementNameOrWildcard ("," TypeName "?"?)?)? ")"
[134]    	ElementNameOrWildcard 	   ::=    	ElementName | "*"
[135]    	SchemaElementTest 	   ::=    	"schema-element" "(" ElementDeclaration ")"
[136]    	ElementDeclaration 	   ::=    	ElementName
[137]    	AttributeName 	   ::=    	QName
[138]    	ElementName 	   ::=    	QName
[139]    	TypeName 	   ::=    	QName
[140]    	URILiteral 	   ::=    	StringLiteral

A.2 Lexical structure

A.2.1 Terminal Symbols

[141]    	IntegerLiteral 	   ::=    	Digits
[142]    	DecimalLiteral 	   ::=    	("." Digits) | (Digits "." [0-9]*) 	/* ws: explicit */
[143]    	DoubleLiteral 	   ::=    	(("." Digits) | (Digits ("." [0-9]*)?)) [eE] [+-]? Digits 	/* ws: explicit */
[144]    	StringLiteral 	   ::=    	('"' (PredefinedEntityRef | CharRef | EscapeQuot | [^"&])* '"') | ("'" (PredefinedEntityRef | CharRef | EscapeApos | [^'&])* "'") 	/* ws: explicit */
[145]    	PredefinedEntityRef 	   ::=    	"&" ("lt" | "gt" | "amp" | "quot" | "apos") ";" 	/* ws: explicit */
[146]    	EscapeQuot 	   ::=    	'""'
[147]    	EscapeApos 	   ::=    	"''"
[148]    	ElementContentChar 	   ::=    	Char - [{}<&]
[149]    	QuotAttrContentChar 	   ::=    	Char - ["{}<&]
[150]    	AposAttrContentChar 	   ::=    	Char - ['{}<&]
[151]    	Comment 	   ::=    	"(:" (CommentContents | Comment)* ":)" 	/* ws: explicit */
				/* gn: comments */
[152]    	PITarget 	   ::=    	[http://www.w3.org/TR/REC-xml#NT-PITarget] XML 	/* xgs: xml-version */
[153]    	CharRef 	   ::=    	[http://www.w3.org/TR/REC-xml#NT-CharRef] XML 	/* xgs: xml-version */
[154]    	QName 	   ::=    	[http://www.w3.org/TR/REC-xml-names/#NT-QName] Names 	/* xgs: xml-version */
[155]    	NCName 	   ::=    	[http://www.w3.org/TR/REC-xml-names/#NT-NCName] Names 	/* xgs: xml-version */
[156]    	S 	   ::=    	[http://www.w3.org/TR/REC-xml#NT-S] XML 	/* xgs: xml-version */
[157]    	Char 	   ::=    	[http://www.w3.org/TR/REC-xml#NT-Char] XML 	/* xgs: xml-version */

The following symbols are used only in the definition of terminal symbols; they are not terminal symbols in the grammar of A.1 EBNF.

[158]    	Digits 	   ::=    	[0-9]+
[159]    	CommentContents 	   ::=    	(Char+ - (Char* ('(:' | ':)') Char*))
